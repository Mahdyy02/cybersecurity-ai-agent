#!/usr/bin/env python3
"""
Vulnerability Scanner Tool
Performs comprehensive vulnerability detection similar to Acunetix
Checks for: SQL Injection, XSS, CSRF, Information Disclosure, Misconfigurations
Outputs results to CSV format
"""

import requests
import csv
import argparse
import sys
import os
import re
import time
from datetime import datetime
from urllib.parse import urlparse, urljoin, parse_qs, urlunparse, urlencode
from bs4 import BeautifulSoup
import warnings
from dotenv import load_dotenv
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

# Load environment variables
load_dotenv()

class VulnerabilityScanner:
    def __init__(self, target_url, output_file):
        self.target_url = target_url
        self.output_file = output_file
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.verify = False
        self.visited_urls = set()
        
        # Get timeout from environment variable (default 60 seconds)
        self.vuln_test_timeout = int(os.getenv('VULN_TEST_TIMEOUT', 60))
        self.sql_test_start_time = None
        self.xss_test_start_time = None
        self.sql_vuln_found = False
        self.xss_vuln_found = False
        
        # SQL Injection payloads
        self.sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin' --",
            "admin' #",
            "admin'/*",
            "' or 1=1--",
            "' or 1=1#",
            "' or 1=1/*",
            "') or '1'='1--",
            "') or ('1'='1--",
            "1' ORDER BY 1--+",
            "1' ORDER BY 2--+",
            "1' ORDER BY 3--+",
            "1' UNION SELECT NULL--",
            "1' UNION SELECT NULL,NULL--",
            "1' UNION SELECT NULL,NULL,NULL--",
            "' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'",
        ]
        
        # XSS payloads
        self.xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            "'-alert('XSS')-'",
            "\"><script>alert('XSS')</script>",
            "'><script>alert('XSS')</script>",
        ]
        
        # SQL error patterns
        self.sql_errors = [
            r"you have an error in your sql syntax",
            r"warning.*mysql_",
            r"unclosed quotation mark after the character string",
            r"quoted string not properly terminated",
            r"sql syntax.*mysql",
            r"warning.*mysqli",
            r"valid mysql result",
            r"mysqlclient\.",
            r"postgresql.*error",
            r"warning.*pg_",
            r"valid postgresql result",
            r"npgsql\.",
            r"driver.* sql[-_ ]*server",
            r"ole db.* sql server",
            r"sql server.*driver",
            r"sql server.*[0-9a-fa-f]{8}",
            r"exception.*\wdriver\w.*\wserver\w",
            r"exception.*\wodbc\w.*\w[sqlserver|access|excel]\w",
            r"microsoft access driver",
            r"jet database engine",
            r"access database engine",
            r"oracle error",
            r"oracle.*driver",
            r"warning.*oci_",
            r"warning.*ora_",
        ]
    
    def add_vulnerability(self, vuln_type, severity, url, parameter, payload, evidence, description):
        """Add a vulnerability to the results"""
        self.vulnerabilities.append({
            'Type': vuln_type,
            'Severity': severity,
            'URL': url,
            'Parameter': parameter,
            'Payload': payload,
            'Evidence': evidence[:500],  # Limit evidence length
            'Description': description,
            'Timestamp': datetime.now().isoformat()
        })
    
    def crawl_website(self, max_pages=50):
        """Crawl the website to find all forms and links"""
        print(f"[*] Crawling website: {self.target_url}")
        
        to_visit = [self.target_url]
        forms = []
        links = []
        
        while to_visit and len(self.visited_urls) < max_pages:
            url = to_visit.pop(0)
            
            if url in self.visited_urls:
                continue
            
            try:
                response = self.session.get(url, timeout=10)
                self.visited_urls.add(url)
                
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Find all forms
                for form in soup.find_all('form'):
                    form_details = self.extract_form_details(form, url)
                    if form_details:
                        forms.append(form_details)
                
                # Find all links
                for link in soup.find_all('a', href=True):
                    href = link['href']
                    full_url = urljoin(url, href)
                    
                    # Only add links from the same domain
                    if urlparse(full_url).netloc == urlparse(self.target_url).netloc:
                        if full_url not in self.visited_urls and full_url not in to_visit:
                            to_visit.append(full_url)
                            
                        # Check if link has parameters
                        if '?' in full_url:
                            links.append(full_url)
                
            except Exception as e:
                print(f"[!] Error crawling {url}: {str(e)}")
                continue
        
        print(f"[+] Crawling completed: {len(self.visited_urls)} pages, {len(forms)} forms, {len(links)} parametrized URLs")
        return forms, links
    
    def extract_form_details(self, form, page_url):
        """Extract form details including action, method, and inputs"""
        try:
            action = form.get('action')
            method = form.get('method', 'get').lower()
            
            # Construct full action URL
            if action:
                action_url = urljoin(page_url, action)
            else:
                action_url = page_url
            
            inputs = []
            for input_tag in form.find_all(['input', 'textarea', 'select']):
                input_type = input_tag.get('type', 'text')
                input_name = input_tag.get('name')
                input_value = input_tag.get('value', '')
                
                if input_name:
                    inputs.append({
                        'type': input_type,
                        'name': input_name,
                        'value': input_value
                    })
            
            return {
                'action': action_url,
                'method': method,
                'inputs': inputs,
                'page_url': page_url
            }
        except Exception as e:
            return None
    
    def test_sql_injection_form(self, form):
        """Test SQL injection on form inputs"""
        # Check if timeout exceeded or vulnerability already found
        if self.sql_vuln_found:
            print(f"[*] Skipping SQL test - vulnerability already proven")
            return
        
        if self.sql_test_start_time and (time.time() - self.sql_test_start_time) > self.vuln_test_timeout:
            print(f"[*] SQL injection test timeout reached ({self.vuln_test_timeout}s)")
            return
        
        if not self.sql_test_start_time:
            self.sql_test_start_time = time.time()
        
        print(f"[*] Testing SQL injection on form: {form['action']}")
        
        for payload in self.sql_payloads:
            for input_field in form['inputs']:
                # Skip non-vulnerable input types
                if input_field['type'] in ['submit', 'button', 'image', 'reset']:
                    continue
                
                # Prepare form data
                data = {}
                for inp in form['inputs']:
                    if inp['name'] == input_field['name']:
                        data[inp['name']] = payload
                    else:
                        data[inp['name']] = inp['value'] if inp['value'] else 'test'
                
                try:
                    if form['method'] == 'post':
                        response = self.session.post(form['action'], data=data, timeout=10)
                    else:
                        response = self.session.get(form['action'], params=data, timeout=10)
                    
                    # Check for SQL error messages
                    response_lower = response.text.lower()
                    for error_pattern in self.sql_errors:
                        if re.search(error_pattern, response_lower, re.IGNORECASE):
                            self.add_vulnerability(
                                vuln_type='SQL Injection',
                                severity='High',
                                url=form['action'],
                                parameter=input_field['name'],
                                payload=payload,
                                evidence=response.text[:500],
                                description=f"SQL error detected in response when testing parameter '{input_field['name']}'"
                            )
                            print(f"[!] SQL Injection vulnerability found: {form['action']} (Parameter: {input_field['name']})")
                            self.sql_vuln_found = True
                            return  # Stop testing once vulnerability is proven
                
                except Exception as e:
                    continue
    
    def test_sql_injection_url(self, url):
        """Test SQL injection on URL parameters"""
        # Check if timeout exceeded or vulnerability already found
        if self.sql_vuln_found:
            print(f"[*] Skipping SQL test - vulnerability already proven")
            return
        
        if self.sql_test_start_time and (time.time() - self.sql_test_start_time) > self.vuln_test_timeout:
            print(f"[*] SQL injection test timeout reached ({self.vuln_test_timeout}s)")
            return
        
        if not self.sql_test_start_time:
            self.sql_test_start_time = time.time()
        
        print(f"[*] Testing SQL injection on URL: {url}")
        
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            for payload in self.sql_payloads:
                # Modify the parameter
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                # Reconstruct URL
                new_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                      parsed.params, new_query, parsed.fragment))
                
                try:
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check for SQL error messages
                    response_lower = response.text.lower()
                    for error_pattern in self.sql_errors:
                        if re.search(error_pattern, response_lower, re.IGNORECASE):
                            self.add_vulnerability(
                                vuln_type='SQL Injection',
                                severity='High',
                                url=url,
                                parameter=param_name,
                                payload=payload,
                                evidence=response.text[:500],
                                description=f"SQL error detected in response when testing parameter '{param_name}'"
                            )
                            print(f"[!] SQL Injection vulnerability found: {url} (Parameter: {param_name})")
                            self.sql_vuln_found = True
                            return  # Stop testing once vulnerability is proven
                
                except Exception as e:
                    continue
    
    def test_xss_form(self, form):
        """Test XSS on form inputs"""
        # Check if timeout exceeded or vulnerability already found
        if self.xss_vuln_found:
            print(f"[*] Skipping XSS test - vulnerability already proven")
            return
        
        if self.xss_test_start_time and (time.time() - self.xss_test_start_time) > self.vuln_test_timeout:
            print(f"[*] XSS test timeout reached ({self.vuln_test_timeout}s)")
            return
        
        if not self.xss_test_start_time:
            self.xss_test_start_time = time.time()
        
        print(f"[*] Testing XSS on form: {form['action']}")
        
        for payload in self.xss_payloads:
            for input_field in form['inputs']:
                # Skip non-vulnerable input types
                if input_field['type'] in ['submit', 'button', 'image', 'reset']:
                    continue
                
                # Prepare form data
                data = {}
                for inp in form['inputs']:
                    if inp['name'] == input_field['name']:
                        data[inp['name']] = payload
                    else:
                        data[inp['name']] = inp['value'] if inp['value'] else 'test'
                
                try:
                    if form['method'] == 'post':
                        response = self.session.post(form['action'], data=data, timeout=10)
                    else:
                        response = self.session.get(form['action'], params=data, timeout=10)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        self.add_vulnerability(
                            vuln_type='Cross-Site Scripting (XSS)',
                            severity='High',
                            url=form['action'],
                            parameter=input_field['name'],
                            payload=payload,
                            evidence=response.text[:500],
                            description=f"XSS payload reflected in response for parameter '{input_field['name']}'"
                        )
                        print(f"[!] XSS vulnerability found: {form['action']} (Parameter: {input_field['name']})")
                        self.xss_vuln_found = True
                        return  # Stop testing once vulnerability is proven
                
                except Exception as e:
                    continue
    
    def test_xss_url(self, url):
        """Test XSS on URL parameters"""
        # Check if timeout exceeded or vulnerability already found
        if self.xss_vuln_found:
            print(f"[*] Skipping XSS test - vulnerability already proven")
            return
        
        if self.xss_test_start_time and (time.time() - self.xss_test_start_time) > self.vuln_test_timeout:
            print(f"[*] XSS test timeout reached ({self.vuln_test_timeout}s)")
            return
        
        if not self.xss_test_start_time:
            self.xss_test_start_time = time.time()
        
        print(f"[*] Testing XSS on URL: {url}")
        
        parsed = urlparse(url)
        params = parse_qs(parsed.query)
        
        if not params:
            return
        
        for param_name in params.keys():
            for payload in self.xss_payloads:
                # Modify the parameter
                test_params = params.copy()
                test_params[param_name] = [payload]
                
                # Reconstruct URL
                new_query = urlencode(test_params, doseq=True)
                test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                      parsed.params, new_query, parsed.fragment))
                
                try:
                    response = self.session.get(test_url, timeout=10)
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        self.add_vulnerability(
                            vuln_type='Cross-Site Scripting (XSS)',
                            severity='High',
                            url=url,
                            parameter=param_name,
                            payload=payload,
                            evidence=response.text[:500],
                            description=f"XSS payload reflected in response for parameter '{param_name}'"
                        )
                        print(f"[!] XSS vulnerability found: {url} (Parameter: {param_name})")
                        self.xss_vuln_found = True
                        return  # Stop testing once vulnerability is proven
                
                except Exception as e:
                    continue
    
    def check_csrf_protection(self, form):
        """Check for CSRF token protection"""
        print(f"[*] Checking CSRF protection on form: {form['action']}")
        
        # Check if form has CSRF token
        has_csrf_token = False
        csrf_token_names = ['csrf', 'csrf_token', 'csrftoken', '_token', 'token', 
                           'authenticity_token', '__requestverificationtoken']
        
        for input_field in form['inputs']:
            if any(token_name in input_field['name'].lower() for token_name in csrf_token_names):
                has_csrf_token = True
                break
        
        # If POST form without CSRF token, it's vulnerable
        if form['method'] == 'post' and not has_csrf_token:
            self.add_vulnerability(
                vuln_type='Cross-Site Request Forgery (CSRF)',
                severity='Medium',
                url=form['action'],
                parameter='N/A',
                payload='N/A',
                evidence='Form uses POST method without CSRF token',
                description='Form is vulnerable to CSRF attacks due to missing anti-CSRF token'
            )
            print(f"[!] CSRF vulnerability found: {form['action']}")
    
    def check_security_headers(self):
        """Check for security-related HTTP headers"""
        print(f"[*] Checking security headers on {self.target_url}")
        
        try:
            response = self.session.get(self.target_url, timeout=10)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (Clickjacking protection)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header',
                'X-XSS-Protection': 'Missing X-XSS-Protection header',
                'Strict-Transport-Security': 'Missing HSTS header (for HTTPS sites)',
                'Content-Security-Policy': 'Missing Content-Security-Policy header'
            }
            
            for header, description in security_headers.items():
                if header not in headers:
                    self.add_vulnerability(
                        vuln_type='Security Misconfiguration',
                        severity='Low' if header != 'Strict-Transport-Security' else 'Medium',
                        url=self.target_url,
                        parameter='HTTP Headers',
                        payload='N/A',
                        evidence=f"Header '{header}' not found in response",
                        description=description
                    )
            
            # Check for information disclosure headers
            disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
            for header in disclosure_headers:
                if header in headers:
                    self.add_vulnerability(
                        vuln_type='Information Disclosure',
                        severity='Low',
                        url=self.target_url,
                        parameter='HTTP Headers',
                        payload='N/A',
                        evidence=f"{header}: {headers[header]}",
                        description=f"Server exposes version information via {header} header"
                    )
        
        except Exception as e:
            print(f"[!] Error checking security headers: {str(e)}")
    
    def check_directory_listing(self):
        """Check for directory listing vulnerability"""
        print(f"[*] Checking for directory listing...")
        
        common_dirs = ['/', '/images/', '/img/', '/css/', '/js/', '/uploads/', 
                      '/files/', '/documents/', '/admin/', '/backup/']
        
        for directory in common_dirs:
            url = urljoin(self.target_url, directory)
            
            try:
                response = self.session.get(url, timeout=10)
                
                # Check for directory listing indicators
                indicators = ['Index of', 'Directory listing', 'Parent Directory', 
                            '<title>Index of', 'Name</th>', 'Last modified</th>']
                
                if any(indicator in response.text for indicator in indicators):
                    self.add_vulnerability(
                        vuln_type='Information Disclosure',
                        severity='Medium',
                        url=url,
                        parameter='N/A',
                        payload='N/A',
                        evidence=response.text[:500],
                        description=f"Directory listing enabled at {directory}"
                    )
                    print(f"[!] Directory listing found: {url}")
            
            except Exception as e:
                continue
    
    def check_sensitive_files(self):
        """Check for sensitive files and backup files"""
        print(f"[*] Checking for sensitive files...")
        
        sensitive_files = [
            '.git/config', '.env', 'web.config', '.htaccess', 'phpinfo.php',
            'robots.txt', 'sitemap.xml', 'crossdomain.xml', 'clientaccesspolicy.xml',
            'backup.zip', 'backup.sql', 'database.sql', 'db_backup.sql',
            'config.php.bak', 'config.php~', 'config.php.old'
        ]
        
        for file in sensitive_files:
            url = urljoin(self.target_url, file)
            
            try:
                response = self.session.get(url, timeout=10)
                
                if response.status_code == 200:
                    self.add_vulnerability(
                        vuln_type='Information Disclosure',
                        severity='High' if any(x in file for x in ['.sql', '.env', 'backup']) else 'Low',
                        url=url,
                        parameter='N/A',
                        payload='N/A',
                        evidence=f"File accessible: {file}",
                        description=f"Sensitive file '{file}' is publicly accessible"
                    )
                    print(f"[!] Sensitive file found: {url}")
            
            except Exception as e:
                continue
    
    def save_to_csv(self):
        """Save vulnerabilities to CSV"""
        if not self.vulnerabilities:
            print("[!] No vulnerabilities found")
            return False
        
        try:
            # Ensure output directory exists
            os.makedirs(os.path.dirname(self.output_file), exist_ok=True)
            
            # Write to CSV
            with open(self.output_file, 'w', newline='', encoding='utf-8') as f:
                fieldnames = ['Type', 'Severity', 'URL', 'Parameter', 'Payload', 
                            'Evidence', 'Description', 'Timestamp']
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                
                writer.writeheader()
                writer.writerows(self.vulnerabilities)
            
            print(f"[+] Results saved to {self.output_file}")
            return True
        except Exception as e:
            print(f"[!] Error saving to CSV: {str(e)}")
            return False
    
    def run(self):
        """Main execution method"""
        print("="*60)
        print("Vulnerability Scanner Tool")
        print("="*60)
        print(f"Target: {self.target_url}")
        print(f"Output: {self.output_file}")
        print("="*60)
        
        # Crawl website
        forms, links = self.crawl_website()
        
        # Check security headers
        self.check_security_headers()
        
        # Check for directory listing
        self.check_directory_listing()
        
        # Check for sensitive files
        self.check_sensitive_files()
        
        # Test SQL injection on forms
        for form in forms:
            self.test_sql_injection_form(form)
            self.test_xss_form(form)
            self.check_csrf_protection(form)
        
        # Test SQL injection on URL parameters
        for link in links:
            self.test_sql_injection_url(link)
            self.test_xss_url(link)
        
        # Save results
        print("\n" + "="*60)
        print(f"Scan completed!")
        print(f"Total vulnerabilities found: {len(self.vulnerabilities)}")
        
        # Count by severity
        high = sum(1 for v in self.vulnerabilities if v['Severity'] == 'High')
        medium = sum(1 for v in self.vulnerabilities if v['Severity'] == 'Medium')
        low = sum(1 for v in self.vulnerabilities if v['Severity'] == 'Low')
        
        print(f"  - High: {high}")
        print(f"  - Medium: {medium}")
        print(f"  - Low: {low}")
        print("="*60)
        
        # Check for SQL Injection vulnerabilities
        sql_vulns = [v for v in self.vulnerabilities if 'SQL Injection' in v['Type']]
        if sql_vulns:
            print(f"\n[!] ⚠️  WEBSITE IS SQL INJECTABLE ⚠️")
            print(f"[!] Found {len(sql_vulns)} SQL Injection vulnerability(ies)")
            print(f"[!] Affected parameters: {', '.join(set(v['Parameter'] for v in sql_vulns))}")
        else:
            print(f"\n[✓] Website is NOT SQL Injectable (no SQL injection vulnerabilities detected)")
        
        # Check for XSS vulnerabilities
        xss_vulns = [v for v in self.vulnerabilities if 'XSS' in v['Type'] or 'Cross-Site Scripting' in v['Type']]
        if xss_vulns:
            print(f"\n[!] ⚠️  WEBSITE IS XSS INJECTABLE ⚠️")
            print(f"[!] Found {len(xss_vulns)} XSS vulnerability(ies)")
            print(f"[!] Affected parameters: {', '.join(set(v['Parameter'] for v in xss_vulns))}")
        else:
            print(f"\n[✓] Website is NOT XSS Injectable (no XSS vulnerabilities detected)")
        
        print("\n" + "="*60)
        
        if self.save_to_csv():
            return True
        
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Vulnerability Scanner Tool - Detects security vulnerabilities',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  python vulnerability_scanner.py --url https://example.com --output results/vulns.csv
  python vulnerability_scanner.py -u http://testsite.local -o output.csv
        '''
    )
    
    parser.add_argument(
        '-u', '--url',
        required=True,
        help='Target URL (e.g., https://example.com)'
    )
    
    parser.add_argument(
        '-o', '--output',
        required=True,
        help='Output CSV file path'
    )
    
    args = parser.parse_args()
    
    # Run the scanner
    scanner = VulnerabilityScanner(args.url, args.output)
    success = scanner.run()
    
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
